# -*- coding: utf-8 -*-
"""Collaborative filtering recommendation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HZADrIQkLMn76f1d0eynSPvzhMqa3LfX
"""

import firebase_admin
from firebase_admin import credentials
from firebase_admin import db
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import csv
from os.path import dirname, join
from com.chaquo.python import Python

def prepare_system():
  # Fetch the service account key JSON file contents
  filename = join(dirname(__file__), 'exchange-items-01-firebase-adminsdk-5kmti-037b8c5561.json')
  cred = credentials.Certificate(filename )

  # Initialize the app with a service account, granting admin privileges
  firebase_admin.initialize_app(cred, {
      'databaseURL': 'https://exchange-items-01-default-rtdb.firebaseio.com/'})
  get_dataset()

def get_dataset():
  ref = db.reference('user')
  # the node is the path
  # print(ref.get())
  #get the user dataset
  snapshot = ref.get()

  files_dir = str(Python.getPlatform().getApplication().getFilesDir())
  with open(files_dir+'exchange_users_dataset.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["_key", "birthday", "email", "UserName", "password", "phoneNum", "userID"])
    for key, val in snapshot.items():
      writer.writerow([key, val.get('birthday'), val.get('email'), val.get('UserName'),val.get('password'), val.get('phoneNum'), val.get('userID')])
  
  #get item dataset 
  ref_items = db.reference('Items') 
  # the node is the path
  #print(ref_items.get())
  snapshot_itemsData = ref_items.get()


  with open(files_dir+'exchange_items_dataset.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["ItemsID", "ownerID", "owner", "ownerEmail", "name", "category", "value"])
    for key, val in snapshot_itemsData.items():
      writer.writerow([key, val.get('ownerID'), val.get('owner'),val.get('ownerEmail'), val.get('name'), val.get('category'), val.get('value') ])

  #get record dataset 
  ref_records = db.reference('exchanged_user_records') 
  # the node is the path
  snapshot_records = ref_records.get()


  with open(files_dir+'exchangedItems_record_dataset.csv', 'w', newline='') as file:
    writer = csv.writer(file)  
    writer.writerow(["record_ID", "userID_providerID", "providedItemsID", "userID_recieverID", "GivenRating"])
    for key, val in snapshot_records.items():
      writer.writerow([key, val.get('userID_provideID'), val.get('providedItemID'), val.get('userID_recieverID'), val.get('GivenRating')])

  rating_popular_usersOwner_pivotTable, num_pivotTable_row = getinformationfromCSV()
  forEachMovieOfUserToRecommend(rating_popular_usersOwner_pivotTable, num_pivotTable_row)



def getinformationfromCSV():
  items = pd.read_csv('exchange_items_dataset.csv', error_bad_lines=False, encoding="latin-1")
  exchangedItems = pd.read_csv('exchangedItems_record_dataset.csv', error_bad_lines=False, encoding="latin-1")
  users = pd.read_csv('exchange_users_dataset.csv', error_bad_lines=False, encoding="latin-1")

  countsUser = exchangedItems['userID_providerID'].value_counts() #count the number of userID in rating table
  exchangedItems = exchangedItems[exchangedItems['userID_providerID'].isin(countsUser[countsUser >= 1].index)]
  providerUser_rating_count = (exchangedItems.groupby(by = ['userID_providerID'])['GivenRating'].count().reset_index().rename(columns={'GivenRating':'totalGivenRatingForEachOwner'})[['userID_providerID','totalGivenRatingForEachOwner']])
  return prepareCSV(items, users, countsUser, exchangedItems, providerUser_rating_count)

def prepareCSV(items, users, countsUser, exchangedItems, providerUser_rating_count):
  combinedDataset_with_totalRatingForEachProvider = pd.merge(exchangedItems, providerUser_rating_count, left_on='userID_providerID', right_on='userID_providerID',how='left' )
  pd.set_option('display.float_format', lambda x: '%.3f' % x)
  print(combinedDataset_with_totalRatingForEachProvider ['totalGivenRatingForEachOwner'].describe())
  popularity_threshold = 1
  rating_popular_usersOwner = combinedDataset_with_totalRatingForEachProvider.query('totalGivenRatingForEachOwner >= @popularity_threshold')
  #list of user
  columns = ['_key', 'birthday','email', 'UserName', 'password', 'phoneNum']
  list_of_userID = users.drop(columns, axis=1)
  list_of_userID = list_of_userID.rename(columns={"userID":"userID_recieverID"})
  #to combine the list some user didnt give a rating (involved in the )
  rating_popular_usersOwner_merge_reciever = pd.merge(rating_popular_usersOwner, list_of_userID, left_on='userID_recieverID', right_on='userID_recieverID', how='right' ) 
  rating_popular_usersOwner_merge_reciever['GivenRating'].fillna(value=0, inplace=True)
  rating_popular_usersOwner_merge_reciever['userID_providerID'].fillna(value=0, inplace=True)
  #form pivot table
  rating_popular_usersOwner_pivotTable = rating_popular_usersOwner.pivot_table(index='userID_providerID', columns='userID_recieverID', values='GivenRating').fillna(0)
  num_pivotTable_row = rating_popular_usersOwner_pivotTable.shape[0]
  return rating_popular_usersOwner_pivotTable, num_pivotTable_row

def forEachMovieOfUserToRecommend(rating_popular_usersOwner_pivotTable, num_pivotTable_row): #suppose to execute for each exchange history of a user  and return list of item 
  selected_index = 0
  # the assumption will be (each row user id mean the user recieved the rating )
  # user id in the column gave the rating 
  # user A on the column (horizontal) login , gave the user B (vertical rating) based on other vertical user, see which other vertical user are similar to vertical user B
  # assume some user login and exchanged the item with user y5Y7KYn0AfSha9OUsFvA8SeQqt72 , and gave rating to y5Y7KYn0AfSha9OUsFvA8SeQqt72, 
  # find out the who other user similar to y5Y7KYn0AfSha9OUsFvA8SeQqt72
  for x in range(0, num_pivotTable_row):
    #print(rating_popular_usersOwner_pivotTable.index[x]) 
    if(rating_popular_usersOwner_pivotTable.index[x]=='y5Y7KYn0AfSha9OUsFvA8SeQqt72'):
      #assume the login user is aZdxnq6MIWGFBiD1WJP2C2lCWt58
      selected_index = x
      print('The index is {0}'.format(selected_index))
  from scipy.sparse import csr_matrix
  rating_popular_usersOwner_df_matrix = csr_matrix(rating_popular_usersOwner_pivotTable.values)
  from sklearn.neighbors import NearestNeighbors

  model_knn = NearestNeighbors(metric = 'cosine', algorithm='brute')
  model_knn.fit(rating_popular_usersOwner_df_matrix)
  distances, indices = model_knn.kneighbors(rating_popular_usersOwner_pivotTable.iloc[selected_index,:].values.reshape(1,-1), n_neighbors=6)
  for i in range(0, len(distances.flatten())):
    if i == 0: # mean it is the same one 
      print('Recommendations for {0}:\n'.format(rating_popular_usersOwner_pivotTable.index[selected_index]))
    else:
      print('{0}: {1}, with distance of {2}:'.format(i, rating_popular_usersOwner_pivotTable.index[indices.flatten()[i]], distances.flatten()[i]))
         #{} to mean the variable the value you are gonna paste there 
    #return list of user
    #with this list of users , we can match the item of the user in the items dataset (so they are the owner ) and the get the categories of the reciever 
    #

prepare_system()
